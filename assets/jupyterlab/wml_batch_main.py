
# generated by cpd_software_env

if __name__ == "__main__" :
    import shutil,json
    import os,sys
    import traceback, logging

    
    # Preamble setting up logging
    #
    # The Job log in WML (CP4D v3) does not include stdout or stderr
    # Therefore, write tracing info into a file in $BATCH_OUTPUT_DIR
    #
    output_dir = os.getenv('BATCH_OUTPUT_DIR')
    if output_dir :
        logfile=os.path.join(output_dir,"system-logging.log")
        logging.basicConfig(filename=logfile,level="DEBUG",
                        format='%(asctime)s %(levelname)-7s %(message)s',
                        datefmt='%H:%M:%S')  
        # https://docs.python.org/3/library/logging.html#levels
    else:
        logging.basicConfig(stream=sys.stdout, level="INFO") # level=logging.DEBUG)
    #
    logging.info("logging started")
    if output_dir and os.getenv('JOBS_PAYLOAD_FILE') :
            shutil.copy(os.environ['JOBS_PAYLOAD_FILE'],output_dir)
            
    #sys.exit(0)  ### DEBUG

    try:
        
        outdir = os.getenv("BATCH_OUTPUT_DIR",".")
        logfile = os.path.join(outdir,"system-logging.log")

    
        # workaround for zen issue 19184
        # https://github.ibm.com/PrivateCloud-analytics/Zen/issues/19184
        #import sys
        #sys.path.append("/opt/ibm/scoring/python/cust-libs")
        
        logging.info("try import cpd_software_env")
        try:
            import cpd_software_env
            logging.info("cpd_software_env available")
            with open(logfile,"a") as fp:
                pkgpath = cpd_software_env.get_path()
                fp.write(f"cpd_software_env path = '{pkgpath}'\n")
                fp.write("cpd_software_env messages:\n")
                fp.write(str(cpd_software_env.get_msgs()))
                fp.write("\n")
        except ModuleNotFoundError:
            logging.warning("No package cpd_software_env found.")

        
        # import the main function of my batch program
        logging.info("import user module")
        from my_batch_hello import my_batch_main
        logging.info("user module available")
        

        payload = None
        # get custom input parameters for this batch job
        if os.getenv('JOBS_PAYLOAD_FILE') :
            with open(os.environ['JOBS_PAYLOAD_FILE'],"r") as json_file :
                payload = json.load(json_file)  
        
        logging.info("Calling my_batch_main")
        with open(logfile,"a") as fp:
            fp.write("Calling my_batch_main:"+str(payload)+"\n")
        sys.stdout = open(os.path.join(outdir,"user-stdout.log"),"w")
        
        # my_batch_main(payload)  # ...

        # map input data to function my_batch_main(wml_args)
        assert isinstance(payload['scoring'],dict), 'wml_data must be a dict'
        data = payload['scoring'].get('input_data_references',[])
        assert isinstance(data,list),'input_data_references must be a list'
        if 0>=len(data) : raise ValueError('Too few arguments in input data for deployed script my_batch_main')
        val_wml_args = data[0]
        scorefn_res = my_batch_main(wml_args=val_wml_args)
        score_res = scorefn_res

        #sys.stdout.close()
        logging.info("Batch script finished")
        #logging.debug(str(score_res))
        resultfile = os.path.join(outdir,"result.json")
        with open(resultfile,"w") as fp:
            import json
            json.dump(score_res, fp)
        #todo: parse into result type by client proxy

    except Exception as ex:
        logging.info("Batch script terminated with an Exception")
        logging.error(traceback.format_exc())
        # re-raise to WML server so the exception appears in the WML log
        # bare raise to re-raise the exception currently being handled)
        # TODO: add option "catchall" to make sure that log files are returned to user
        #raise  # forwarding previous exception
        # Problem: If the deployed script returns an exception then WML won't upload
        # the logging files as a data asset (zip file)
        # Instead, write "error file"
        errorfile = os.path.join(outdir,"ERROR.txt")
        with open(errorfile,"w") as fp:
            fp.write(str(traceback.format_exc()))
        
            
    finally:
        logging.info("shutdown")
        logging.shutdown()
